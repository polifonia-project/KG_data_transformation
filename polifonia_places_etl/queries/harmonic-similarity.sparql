# Query to extract data from preprocessed file with places related to Music domain
# and build a Knowledge Graph according to Polifonia places ontology, using sparql.anything
#
# from following datasets:
#      -
#      -
#
# Raw file: https://raw.githubusercontent.com/polifonia-project/sonar2021_demo/datasets/places/places.json
# 
# Polifonia KG ontology: https://github.com/polifonia-project/sonar2021_demo/issues/14



# POLIFONIA prefixes
PREFIX core:    <https://w3id.org/polifonia/ON/core/> 
PREFIX mp:      <https://w3id.org/polifonia/ON/musical-performance/>
PREFIX mc:      <https://w3id.org/polifonia/ON/musical-composition/>
PREFIX mf:      <https://w3id.org/polifonia/ON/musical-feature/>
PREFIX cm:      <https://w3id.org/polifonia/ON/comparative-measure/>
PREFIX rdf:     <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs:    <http://www.w3.org/2000/01/rdf-schema#>
PREFIX pr:      <https://w3id.org/polifonia/resource/>

# SPARQL anything prefixes
PREFIX fx:  <http://sparql.xyz/facade-x/ns/>
PREFIX xyz: <http://sparql.xyz/facade-x/data/>


CONSTRUCT { 

    # Recording
    ?recordingAIRI   a mp:Recording ;
                    mf:hasChordProgression ?chordProgressionAIRI ;
                    cm:isHarmonicallySimilarTo ?RecordingBIRI .

    ?recordingBIRI a mp:Recording ;
                    mf:hasChordProgression ?chordProgressionBIRI ;
                    cm:isHarmonicallySimilarTo ?RecordingAIRI .

    # ChordProgression
    ?chordProgressionAIRI   a mf:ChordProgression ;
                    mf:isChordProgressionOf ?recordingAIRI .

    ?chordProgressionBIRI   a mf:ChordProgression ;
                    mf:isChordProgressionOf ?recordingBIRI .

    # HarmonicSimilarity
    ?harmonicSimIRI a cm:HarmonicSimilarity ;
                    cm:involvesRecording ?recordingAIRI ;
                    cm:involvesRecording ?recordingBIRI ;
                    cm:involvesChordProgression ?chordProgressionAIRI ;
                    cm:involvesChordProgression ?chordProgressionAIRI ;
                    cm:hasSimScore ?simScore ;
                    cm:hasSimFunction ?simFunction ;
                    cm:hasEncoding ?encoding .

}
    

    WHERE {


    SERVICE <x-sparql-anything:> {

        fx:properties fx:location "data/harmonic-sym.csv"  ;
        fx:media-type "text/csv" ;
        fx:csv.headers true ;  
        fx:blank-nodes false    .

        ?row xyz:recordingA ?recordingA ;
             xyz:recordingB ?recordingB ; 
             xyz:chordProgressionA ?chordProgressionA ;
             xyz:chordProgressionB ?chordProgressionB ; 
             xyz:simScore ?simScore .

    } .


    # generate resources IRIs from string IDs
    BIND(IRI(CONCAT( STR(pr:) , "Recording/", ENCODE_FOR_URI(?recordingA))) AS ?recordingAIRI)
    BIND(IRI(CONCAT( STR(pr:) , "Recording/", ENCODE_FOR_URI(?recordingB))) AS ?recordingBIRI)
    BIND(IRI(CONCAT( STR(pr:) , "ChordProgression/", ENCODE_FOR_URI(?chordProgressionA))) AS ?chordProgressionAIRI)
    BIND(IRI(CONCAT( STR(pr:) , "ChordProgression/", ENCODE_FOR_URI(?chordProgressionB))) AS ?chordProgressionBIRI)
    BIND(IRI(CONCAT( STR(pr:) , "HarmonicSimilarity/", ENCODE_FOR_URI(?recordingAIRI), "_", ENCODE_FOR_URI(?recordingBIRI))) AS ?harmonicSimIRI)



    # individuals IRIs from string IRI
    BIND(IRI(?sessionType) AS ?sessionTypeIndividualIRI)

} 
